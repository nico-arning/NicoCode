#.libPaths("./datapond/Dependencies/R_libs")
packages = c(
  "tidyr",
  "magrittr",
  "ggplot2",
  "withr",
  "stringr",
  "data.table",
  "memoise",
  "tzdb",
  "forcats",
  "lubridate",
  "readr",
  "nlme",
  "robustbase",
  "backports",
  "mgcv",
  "tidyverse",
  "ggplot2",
  "BiocGenerics",
  "S4Vectors",
  "matrixStats",
  "MatrixGenerics",
  "IRanges",
  "Biobase",
  "GenomeInfoDb",
  "GenomicRanges",
  "SummarizedExperiment",
  "DESeq2",
  "readxl",
  "gplots",
  "RColorBrewer",
  "pheatmap",
  "data.table",
  "ggrepel",
  "genefilter",
  "BiocParallel",
  "sva",
  "rrcov",
  "limma",
  "findpython",
  "argparse",
  "BiocParallel",
  "ggpubr",
  "backports",
  "cowplot",
  "FactoMineR",
  "Matrix",
  "PCAtools",
  "ggrepel",
  #"scSHC",
  "ggpubr",
  "egg",
  "RColorBrewer",
  "scales",
  "latticeExtra",
  "AnnotationHub",
  "GOplot",
  "pathview",
  "clusterProfiler",
  "AnnotationHub",
  "enrichplot",
  "EnhancedVolcano"
)


lapply(packages, require, character.only = TRUE)    # Load multiple packages

#' Read in data
#'
#' Reads in output data from Starsolo alongside meta data for input to DeSeq2
#' @param matrix_file Location of the count matrix generated by STARsolo
#' @param features_file Location of the file containing the row names
#'  of the count matrix generated by STARsolo
#' @param barcodes_file Location of the file containing the columns names
#'  of the count matrix generated by STARsolo
#' @param plate_design The location of the excel file containing the meta data
#' @param plate_number The number of plates in the experiment
#' @param sheet_treatment The name of the sheet containing the treatment information
#' inside the excel file
#'
#' @return Returns the count matrix and the meta data
#' @export
#'
read_in_data = function(matrix_file, features_file, barcodes_file, plate_design, plate_number, sheet_treatment, sheet_concentration) {
  plate_name = paste0(plate_number) # Name of the plate
  
  # Read in count matrix (is in sparse format)
  matrix = as.data.frame(as.matrix( readMM( matrix_file)))
  
  # Get the gene names as column names
  feature.names = fread(
    paste0(features_file), # 
    header = FALSE,
    stringsAsFactors = FALSE,
    data.table = F
  )
  rownames(matrix) = feature.names$V1
  
  # Get the barcodes as row names
  barcode.names = fread(
    paste0(barcodes_file),
    header = FALSE,
    stringsAsFactors = FALSE,
    data.table = F
  )
  colnames(matrix) = barcode.names$V1
  
  # Read in the excel sheet containing the meta information
  # Read in Treatment information
  treatments = read_excel(plate_design, sheet = sheet_treatment)
  treatments = as.data.frame(treatments)
  treatments$Treatments = treatments$Treatments
  rownames(treatments) = treatments$Treatments
  #colnames(treatments) = gsub(" ", "", colnames(treatments))
  treatments = treatments[, colnames(treatments) != "Treatments"]
  
  # Get some information from the metadata
  number_rows = nrow(treatments)
  number_cols = ncol(treatments)
  plate_format = number_rows * number_cols
  all_rows = rownames(treatments)
  
  # Parse treatments
  treatments_array = c(t(as.matrix(treatments)))
  treatments_array = gsub(' ', '_', treatments_array)
  treatments_array = gsub(" ", "", treatments_array)
  treatments_array <- gsub("untreated", "Untreated", treatments_array, ignore.case = TRUE)
  #treatments_array <- gsub("", "Untreated", treatments_array, ignore.case = TRUE)
  treatments_array[is.na(treatments_array)] <- "Untreated"

  treatments_array = gsub("[[:punct:]]", "", treatments_array)

  
  # Read in concentrations
  concentrations = read_excel(plate_design, sheet = sheet_concentration)

  concentrations = as.data.frame(concentrations)

  rownames(concentrations) = concentrations$Concentrations
  concentrations = concentrations[, colnames(concentrations) != "Concentrations"]
  concentrations_array = c(t(as.matrix(concentrations)))
  #concentrations_array = gsub(" .*", "", concentrations_array) # Âµ symbol difficult to parse

  concentrations_array = gsub(',', '.', concentrations_array)
  
  # Get dummy concentrations for the DMSO controls (or otherwise empty wells)
  num_DMSO = length(concentrations_array[treatments_array == "DMSO"])
  num_empty = length(concentrations_array[treatments_array == "Empty"])
  num_untreated = length(concentrations_array[treatments_array == "Untreated"])
  conc_array = unique(concentrations_array)
  conc_array = conc_array[ !conc_array == 0]
  conc_array = conc_array[ !conc_array == "Untreated"]
  conc_array = conc_array[ !conc_array == "DMSO"]

  conc_array = conc_array[ !is.na(conc_array)]

  concentrations_array[treatments_array == "DMSO"] = sample(conc_array, num_DMSO, replace=TRUE)
  concentrations_array[treatments_array == "Empty"] = sample(conc_array, num_empty, replace=TRUE)
  concentrations_array[treatments_array == "Untreated"] = sample(conc_array, num_untreated, replace=TRUE)
  
  # Get rid of values that bother the analysis
  concentrations_array = as.numeric(concentrations_array)
  concentrations_array[concentrations_array == 0] = sample(conc_array, 1)
  concentrations_array[concentrations_array == NA] = sample(conc_array, 1)
  concentrations_array[is.na(concentrations_array)] = sample(conc_array, 1)

  # Read in barcodes
  barcodes = read_excel(plate_design, sheet = "Barcodes")
  barcodes = as.data.frame(barcodes)

  rownames(barcodes) = barcodes$Barcodes
  barcodes = barcodes[, colnames(barcodes) != "Barcodes"]
  barcodes_array = c(t(as.matrix(barcodes)))
  cell_name_array = do.call(paste0, rev(expand.grid(1:number_cols, all_rows)))
  # Put all the metadata in one array

  plate_matrix_data = c(
    cell_name_array,
    treatments_array,
    concentrations_array,
    barcodes_array
  )
  
  coln = c("Wellnames",
           "Treatments",
           "Concentrations",
           "Barcodes"
  )
  
  rown = seq(1, plate_format, 1)
  
  # Make a matrix out of the array
  plate_matrix = matrix( plate_matrix_data,
                         nrow = length(rown),
                         ncol = length(coln),
  )
  
  # Get the column names and rownames
  colnames(plate_matrix) = c("Wellnames",
                             "Treatments",
                             "Concentrations",
                             "Barcodes"
  )
  rownames(plate_matrix) = do.call(paste0, rev(expand.grid(1:number_cols, all_rows)))
  # Order plate matrix by cell ids Starsolo used
  plate_matrix = as.data.frame(plate_matrix)

  matrix = matrix[, order(colnames(matrix))]
  plate_matrix = plate_matrix[order(plate_matrix$Barcodes),]
  
  # Get the plate number in as information for batch correction later
  plate_matrix$Plate = plate_name
  plate_matrix$Plate = as.factor( plate_matrix$Plate)
  
  # A sum of all
  plate_matrix$ReadSumsPerWell = colSums(matrix)
  #plate_matrix$ReadSumsPerWellQcut = cut(plate_matrix$ReadSumsPerWell, quantile(plate_matrix$ReadSumsPerWell, 0:10/10))
  #plate_matrix$ReadSumsPerWellQcut = as.factor(plate_matrix$ReadSumsPerWellQcut)
# 
  rownames(plate_matrix) = paste0(plate_matrix$Barcodes, "_",plate_matrix$Plate)
  colnames(matrix) = paste0(colnames(matrix), "_", rep(plate_name, ncol(matrix)))

  plate_matrix = plate_matrix[!is.na(plate_matrix$Concentrations),]
  plate_matrix = plate_matrix[!is.na(plate_matrix$Treatments),]
  plate_matrix = plate_matrix[plate_matrix$Treatments != "Untreated",]
  plate_matrix = plate_matrix[plate_matrix$Treatments != "Empty",]
  matrix = matrix[, rownames(plate_matrix)]

  plate_matrix$Wellnames = paste0(plate_matrix$Wellnames, "_", plate_matrix$Plate)
  
  plate_matrix$Concentrations = as.numeric(plate_matrix$Concentrations)
  plate_matrix$logdose = log10(plate_matrix$Concentrations)
  
  return(list(matrix = matrix, plate_matrix = plate_matrix))
  
}


#' Wrapper around read_in_data so can be applied to plates
#'
#' @param read_pools Start of the pooled fastq files they were pooled by
#' @param sheet_treatments Sheet within the excel spreadsheet that defines treatments
#' @param meta_data Excel spreadsheet containing meta information
#'
#' @return Count matrix and meta data
#' @export
#'
#' @examples
read_in_meta = function(read_pools, sheet_treatments, sheet_concentrations, meta_data, accession) {
  for (i in 1:length(read_pools)) {

    solo_output_path = paste0("./STAR/", read_pools[i] , "_CountTables/")
    features_file = paste0( solo_output_path, "features.tsv")
    barcodes_file = paste0( solo_output_path, "barcodes.tsv")
    plate_design = meta_data
    matrix_file = paste0( solo_output_path, "umiDedup-1MM_All.mtx")
    
    output = read_in_data(
      matrix_file, 
      features_file,
      barcodes_file, 
      plate_design,
      i,
      sheet_treatments[i],
      sheet_concentrations[i])
    if( i==1 ) {
      matrix = output$matrix
      plate_matrix = output$plate_matrix
    } else {
      matrix = cbind(matrix, output$matrix)

      plate_matrix = rbind(plate_matrix, output$plate_matrix)
    }
  }
  plate_matrix = plate_matrix[plate_matrix$Treatments != "empty",]
  plate_matrix = plate_matrix[plate_matrix$Treatments != "Untreated",]

matrix = matrix[, rownames(plate_matrix)]


  stopifnot( exprs = {
    all(colnames(matrix) %in% rownames(plate_matrix))
    all(colnames(matrix) == rownames(plate_matrix))
  })
  
  matrix = matrix[, order(colnames(matrix))]
  plate_matrix = plate_matrix[order(rownames(plate_matrix)),]
  
  return(list(matrix = matrix, plate_matrix = plate_matrix))
}

#' Differential expression function
#'
#' @param matrix Count matrix
#' @param plate_matrix Matrix containing meta data
#' @param plate_number Number of plates
#'
#' @return dds is the deseq object containing the analysis. 
#' vsd are the variance stabilised counts
#' @export
#'
#' @examples
differential_expression = function(matrix, plate_matrix, plate_number) {
  result <- plate_matrix %>%
    group_by(Treatments) %>%
    summarise(unique_logdose_count = n_distinct(logdose)) %>%
    ungroup()
  # Check if every Treatment only has one associated dose
  all_one_unique_logdose <- all(result$unique_logdose_count == 1)
  if( all_one_unique_logdose) {
    design = formula( ~ Treatments)
  } else if( plate_number == 1) {
    # If there is only one plate then don't include plate info in experimental design
    design = formula(~ Treatments*logdose)
  } else {
    # If none of the above is true model the phenotype as an interaction of concentration
    # and treatment with plate as a covariate
    design = formula( ~ Plate + Treatments)
  }
  design = formula(~ Treatments)

  keep_rows = rowSums( matrix >= 10 ) >= 3
  matrix = matrix[keep_rows, ]
  matrix = matrix[, rownames(plate_matrix)]

  # Create data object 
  dds = tryCatch( {
    DESeqDataSetFromMatrix(
      countData = matrix,
      colData = plate_matrix,
      design = design)
  }, error = function(e) DESeqDataSetFromMatrix(
    countData = (matrix + 1),
    colData = plate_matrix,
    design = design)
  )
  
  # A bit of light filtering
  #keep = rowSums(counts(dds))/ncol(counts(dds)) > 0.05

  #dds = dds[keep,]
  
  # Relevel so DMSO is control
  dds$Treatments = relevel(factor(dds$Treatments), ref = "DMSO")
  
  # Do the differential expression analysis
  dds = DESeq(
    dds, 
    parallel=TRUE,
    #test="LRT",
    #useT=TRUE,
    #minmu=1e-6,
    #minReplicatesForReplace=Inf,
    #reduced = ~ Plate,
    #sizeFactors = scran::computeSumFactors   
  )
  
  # Do the variance stabilising transformation
  vsd = varianceStabilizingTransformation(dds)
  
  return(list(dds = dds, vsd = vsd))
  
}
#' Flag outliers automatically by applying a standard deviation filter
#'
#' @param vsd Variance stabilised count data
#'
#' @return Names of wells that could be outliers
#' @export
#'
#' @examples
outlier_removal_pca = function(vsd){
  pcaHub = PcaGrid(t(assay(vsd)))
  outliers = names(which(pcaHub@flag=='FALSE'))
  return(outliers)
}

#' Make a PCA alongside some other plots that are supposed
#' to explain what goes into the principal components
#'
#' @param vsd  Variance stabilised count data
#' @param plate_number Number of plates
#' @param plate_matrix Matrix containing meta data
#' @param file_name Name of the otuput file to put the plot in
#' @param colouring Name of the column of the metadta to colour the PCA by
#'
#' @return Nothing
#' @export
#'
#' @examples
make_pca = function(vsd, plate_matrix, file_name, colouring=vsd$Treatments){
  
  # Fill NAs with 0
  assay(vsd)[is.nan(assay(vsd))] = 0
  plate_matrix[is.na(plate_matrix)] = 0
  
  # Parse the wellnames
  #vsd$Wellnames = sapply(strsplit(as.character(vsd$Wellnames), "_"), `[`, 1)
  # Get the data for the PCA
  pcaData = plotPCA( vsd,
                     intgroup = c("Treatments", "Concentrations", "Outlier", "Wellnames"),
                     returnData=TRUE,
                     ntop=500
  )
  
  # Calculate the variance for each gene
  rv = rowVars(assay(vsd))
  
  # Select the ntop genes by variance
  select = order(rv, decreasing=TRUE)[seq_len(min(500, length(rv)))]
  
  # Perform another type of PCA on the because it has additional visualisations
  pca = prcomp(t(assay(vsd)[select,]))
  
  # Plot which columns of the meta data plays into the Principal components the most
  #variance_plot = fviz_eig(pca, addlabels = TRUE)
  
  # Which genes go into the first principal component
  #loading_plot = fviz_cos2(pca, choice = "var", axes = 1, top = 20)
  
  # PCA plot with ellipses
  #cluster_plot = fviz_pca_ind(pca,
  #                            label = "none", # hide individual labels
  #                            habillage = vsd$Treatments, # color by groups
  #                            addEllipses = TRUE # Concentration ellipses
  #)
  
  # Another PCA with different plotting capabilities
  #p = pca(assay(vsd)[select,], metadata = plate_matrix)
  
  # Plot which factors play into principal components
  #if(length(unique(vsd$Plate)) > 1) {
  #  eigencor = eigencorplot(p,
  #                          metavars = c("Treatments","Concentrations",'ReadSumsPerWell', 'Plate'))
  #} else {
  #  eigencor = eigencorplot(p,
  #                          metavars = c("Treatments","Concentrations",'ReadSumsPerWell'))
  #}
  
  
  percentVar = round(100 * attr(pcaData, "percentVar"))
  pca_plot = ggplot(pcaData, aes(PC1, PC2, color=colouring, shape=as.factor(Concentrations), label=Treatments, shape=Outlier)) +
    geom_point(size=3) + scale_shape_manual(values=1:nlevels(as.factor(pcaData$Concentrations))) +
    geom_text_repel(max.overlaps = 1000) +
    geom_point(data=pcaData[pcaData$Outlier == "Outlier", ], 
               aes(x=PC1,y=PC2), 
               color='black',
               shape="x",
               size=3) +
    xlab(paste0("PC1: ",percentVar[1],"% variance")) +
    ylab(paste0("PC2: ",percentVar[2],"% variance")) +
    coord_fixed()
  
  # These have stopped working when I updated the packages
  
  #arranged_plot = ggarrange(pca_plot, variance_plot, loading_plot , eigencor,
  #ncol = 2, nrow = 2)
  
  # So instead its just the normal PCA
  arranged_plot = pca_plot
  #arranged_plot = ggarrange(tmp_plot, eigencor, nrow=2, heights=c(0.6, 0.4))
  
  # Save plot
  ggsave(
    file_name,
    plot = arranged_plot,
    dpi = 300,
    bg = 'white',
    width = 15, 
    height = 15,
    unit="in"
  )
}

make_pca_labels = function(vsd, plate_matrix, file_name, colouring=vsd$Treatments){
  
  # Fill NAs with 0
  assay(vsd)[is.nan(assay(vsd))] = 0
  plate_matrix[is.na(plate_matrix)] = 0
  
  # Parse the wellnames
  #vsd$Wellnames = sapply(strsplit(as.character(vsd$Wellnames), "_"), `[`, 1)
  # Get the data for the PCA
  pcaData = plotPCA( vsd,
                     intgroup = c("Treatments", "Concentrations", "Outlier", "Wellnames"),
                     returnData=TRUE,
                     ntop=500
  )
  
  # Calculate the variance for each gene
  rv = rowVars(assay(vsd))
  
  # Select the ntop genes by variance
  select = order(rv, decreasing=TRUE)[seq_len(min(500, length(rv)))]
  
  # Perform another type of PCA on the because it has additional visualisations
  pca = prcomp(t(assay(vsd)[select,]))
  
  # Plot which columns of the meta data plays into the Principal components the most
  #variance_plot = fviz_eig(pca, addlabels = TRUE)
  
  # Which genes go into the first principal component
  #loading_plot = fviz_cos2(pca, choice = "var", axes = 1, top = 20)
  
  # PCA plot with ellipses
  #cluster_plot = fviz_pca_ind(pca,
  #                            label = "none", # hide individual labels
  #                            habillage = vsd$Treatments, # color by groups
  #                            addEllipses = TRUE # Concentration ellipses
  #)
  
  # Another PCA with different plotting capabilities
  #p = pca(assay(vsd)[select,], metadata = plate_matrix)
  
  # Plot which factors play into principal components
  #if(length(unique(vsd$Plate)) > 1) {
  #  eigencor = eigencorplot(p,
  #                          metavars = c("Treatments","Concentrations",'ReadSumsPerWell', 'Plate'))
  #} else {
  #  eigencor = eigencorplot(p,
  #                          metavars = c("Treatments","Concentrations",'ReadSumsPerWell'))
  #}
  
  
  percentVar = round(100 * attr(pcaData, "percentVar"))
  pca_plot = ggplot(pcaData, aes(PC1, PC2, color=colouring, shape=as.factor(Concentrations), label=Treatments, shape=Outlier)) +
    geom_point(size=3) + scale_shape_manual(values=1:nlevels(as.factor(pcaData$Concentrations))) +
    geom_text_repel(max.overlaps = 1000) +
    geom_point(data=pcaData[pcaData$Outlier == "Outlier", ], 
               aes(x=PC1,y=PC2), 
               color='black',
               shape="x",
               size=3) +
    xlab(paste0("PC1: ",percentVar[1],"% variance")) +
    ylab(paste0("PC2: ",percentVar[2],"% variance")) +
    coord_fixed()
  
  # These have stopped working when I updated the packages
  
  #arranged_plot = ggarrange(pca_plot, variance_plot, loading_plot , eigencor,
  #ncol = 2, nrow = 2)
  
  # So instead its just the normal PCA
  arranged_plot = pca_plot
  #arranged_plot = ggarrange(tmp_plot, eigencor, nrow=2, heights=c(0.6, 0.4))
  
  # Save plot
  ggsave(
    file_name,
    plot = arranged_plot,
    dpi = 300,
    bg = 'white',
    width = 15, 
    height = 15,
    unit="in"
  )
}


#' Make a UMAP and PCA and highlight clusters based on Seurat clustering
#'
#' @param vsd Variance stabilised counts
#' @param corrected_counts Corrected counts from DeSeq
#' @param plate_matrix Matrix containing meta data
#' @param file_name Name of the file to put the output plot in
#'
#' @return
#' @export
#'
#' @examples
make_umap_clusters = function(vsd, corrected_counts, plate_matrix, file_name){
  
  # Callculate row variance
  rv = rowVars(assay(vsd))
  
  # select the ntop genes by variance
  select = order(rv, decreasing=TRUE)[seq_len(min(500, length(rv)))]
  
  # Make a PCA
  pcaData = plotPCA( vsd[select,],
                     intgroup = c("Treatments", "Concentrations"),
                     #ntop=500,
                     returnData=TRUE
  )
  
  # Some data wrangling to prep data for UMAP 
  corrected_counts = as.matrix(corrected_counts)
  vsd$Treatments = as.factor(vsd$Treatments)
  umap_data = as.data.frame(umap(t(corrected_counts))$layout)
  
  # Use both UMAP and PCA clustering (2 columns)
  # To show wells with treatments highliht, srSHC clustering and Seurat clustering (3 rows)
  # Arrange in a plot made up of 6 individual plots
  
  # PCA block
  pca_treatments_plot = make_scatter(pcaData, pcaData$PC1, pcaData$PC2,  vsd$Treatments, vsd$Treatments, as.factor(vsd$Concentrations), "PC 1", "PC 2", "PCA of variance stabilised counts with Treatments")
  pca_clusters_sc_plot = make_scatter(pcaData, pcaData$PC1, pcaData$PC2,  vsd$Treatments, vsd$sc_SCH_Clusters, as.factor(vsd$Concentrations), "PC 1", "PC 2", "PCA of variance stabilised counts with sc HCA clusters")
  pca_clusters_seurat_plot = make_scatter(pcaData, pcaData$PC1, pcaData$PC2,  vsd$Treatments, vsd$Seurat_clusters, as.factor(vsd$Concentrations), "PC 1", "PC 2", "PCA of variance stabilised counts with Seurat clusters")
  
  # UMAP block
  umap_treatments_plot = make_scatter(umap_data, umap_data$V1, umap_data$V2, vsd$Treatments, vsd$Treatments, as.factor(vsd$Concentrations), "UMAP 1", "UMAP 2", "Umap of corrected counts with Treatments")
  umap_clusters_sc_plot = make_scatter(umap_data, umap_data$V1, umap_data$V2,  vsd$Treatments, vsd$sc_SCH_Clusters, as.factor(vsd$Concentrations), "UMAP 1", "UMAP 2", "Umap of corrected counts with sc HCA clusters")
  umap_clusters_seurat_plot = make_scatter(umap_data, umap_data$V1, umap_data$V2,  vsd$Treatments, vsd$Seurat_clusters, as.factor(vsd$Concentrations), "UMAP 1", "UMAP 2", "Umap of corrected counts with Seurat clusters")
  
  # Arrange plot together
  arranged_plot = ggarrange(
    pca_treatments_plot,
    umap_treatments_plot,
    pca_clusters_sc_plot, 
    umap_clusters_sc_plot,
    pca_clusters_seurat_plot,
    umap_clusters_seurat_plot,
    nrow=3, 
    ncol=2)
  
  # Give figure titles
  annotate_figure(arranged_plot, top = "PCA                               UMAP")
  
  # Save plot
  ggsave(
    file_name,
    plot = arranged_plot,
    dpi = 300,
    bg = 'white',
    width = 22, 
    height = 22,
    unit="in"
  )
  
  # Combine treatments and concentrations into one column for annotation
  vsd$TreatConc = paste(vsd$Treatments, vsd$Concentrations)
  
  # Make one big scatterplot of seurat clustering with the treatments and concentrations as labels
  seurat_big =  make_scatter_big(umap_data, umap_data$V1, umap_data$V2,  vsd$TreatConc, vsd$Seurat_clusters, as.factor(vsd$Concentrations), "UMAP 1", "UMAP 2", "Umap of corrected counts with Seurat clusters")
  
  # Save plot
  ggsave(
    "./DeSeq/Plots/Seurat_cluster_big.png",
    plot = seurat_big,
    dpi = 300,
    bg = 'white',
    width = 25, 
    height = 25,
    unit="in"
  )
}

#' Make a scatter plot for the make_umap_clusters plot
#'
#' @param data Matrix to draw the data from
#' @param x x value data
#' @param y y value data
#' @param color_col Information for colouring
#' @param ellipse_col Information for drawing ellipses
#' @param shape data to use for differing shapes
#' @param xlab label of x axis
#' @param ylab label of y axis
#' @param plot_title title of plot
#'
#' @return scatterplot
#' @export
#'
#' @examples
make_scatter = function(data, x, y, color_col, ellipse_col, shape, xlab, ylab, plot_title) {
  g = ggplot(data, aes(x, y)) +
    geom_point(aes(x, y, color = color_col,group=color_col, pch=as.factor(shape)), size=3) +
    stat_ellipse(data = data, aes(x=x, y=y, color = ellipse_col, group=ellipse_col), inherit.aes=FALSE) +
    labs(title=plot_title, x =xlab, y = ylab) 
  return(g)
}

#' The same as make_scatter but bigger
#'
#' @param data Matrix to draw the data from
#' @param x x value data
#' @param y y value data
#' @param color_col Information for colouring
#' @param ellipse_col Information for drawing ellipses
#' @param shape data to use for differing shapes
#' @param xlab label of x axis
#' @param ylab label of y axis
#' @param plot_title title of plot
#'
#' @return scatterplot
#' @export
#'
#' @examples
make_scatter_big = function(data, x, y, color_col, ellipse_col, shape, xlab, ylab, plot_title) {
  g = ggplot(data, aes(x, y, label = color_col)) +
    geom_point(aes(x, y, color = ellipse_col,group=ellipse_col, pch=as.factor(shape)), size=3) +
    geom_text_repel(aes(x = x, 
                        y = y, 
                        label = color_col)) +
    stat_ellipse(data = data, aes(x=x, y=y, color = ellipse_col, group=ellipse_col), inherit.aes=FALSE) +
    labs(title=plot_title, x =xlab, y = ylab) 
  
  return(g)
}

#' Plot the sum of aligned reads per well
#'
#' @param plate_matrix Matrix containing meta data
#'
#' @return Nothing
#' @export
#'
#' @examples
reads_per_well_plot = function(plate_matrix) {
  reads_per_well = ggplot(plate_matrix, aes(x=Wellnames, y=ReadSumsPerWell, color=Treatments)) + 
    geom_bar(stat="identity", fill="white") +
    theme(axis.ticks.x=element_blank())
  
  ggsave(
    paste0("./DeSeq/Plots/ReadsPerWell.png"),
    plot = reads_per_well,
    width = 15,
    height = 15,
    units = "cm",
    dpi = 300,
    
  )
  
  reads_per_well_corrected = ggplot(plate_matrix, aes(x=Wellnames, y=CorrectedReadsPerWell, color=Treatments)) +
    geom_bar(stat="identity", fill="white")
  
  ggsave(
    paste0("./DeSeq/Plots/ReadsPerWellCorrected.png"),
    dpi = 300
  )
  
}

#' Plot the distribution of aligned reads per well
#'
#' @param matrix Count matrix
#' @param plate_matrix Matrix with meta data
#' @param count_type Whether corrected or uncorrected counts
#'
#' @return
#' @export
#'
#' @examples
sparse_plot = function(matrix, plate_matrix, count_type) {
  Aligned_reads = c(t(matrix))
  Treatment = rep(plate_matrix$Treatments, nrow(matrix))
  Concentrations = rep(plate_matrix$Concentrations, nrow(matrix))
  
  new_df = data.frame(Aligned_reads, Treatment, Concentrations)
  p2 = ggplot(data=new_df, aes(x=Aligned_reads,  color=Treatment, fill = Treatment), show.legend = FALSE) +
    geom_histogram(show.legend = FALSE) +
    facet_grid(Treatment ~ Concentrations, margins=TRUE, switch = "y", scales = "free_y") +
    theme(strip.text.y.left = element_text(angle = 0)) +
    scale_y_continuous(trans='log2') 
  
  ggsave(
    paste0("./DeSeq/Plots/", count_type, "_distribution_plot.png"),
    width=15, 
    height=15,
    plot = p2,
    dpi = 300
  )
}


#' Make enhanced Volcano plot
#'
#' @param dds Deseq object
#' @param treatment Name of the treatment
#' @param condition Which column to look at for contrast
#' @param control Name of the control variable
#' @param alpha Significance level
#'
#' @return
#' @export
#'
#' @examples
volcano_plot = function(dds, treatment, condition, control = "DMSO", alpha = 0.05) {
  # Results of contrasting treatment vs controls
  # This results table contains genes as rows and different statistics as columns
  # Among the columns there are fold changes p-values and other interesting things
  res = results(
    dds,
    alpha = alpha,
    contrast = c(
      condition,
      treatment,
      control
    ),
  )
  # Also save the underlying results table for further plotting with python
  out_table = paste0("../Tables/", treatment, "_differential_expression.tsv")
  write.table(res, 
              file = out_table,
              quote = FALSE, 
              sep = '\t',
              col.names = NA)
    

  ## Make volcano plot
  volcano = EnhancedVolcano(res,
                            lab = rownames(res),
                            x = 'log2FoldChange',
                            y = 'pvalue',
                            title = paste0(treatment, " vs. DMSO"),
                            FCcutoff = 1,
                            pCutoff = alpha,
  )
  
  ## Save volcano plot
  ggsave(
    paste0("./", treatment, "_volcano_plot.png"),
    plot = volcano,
    dpi = 300
  ) 

}

#' Seurat clustering borrowed from Single cell rna clustering methods
#'
#' @param counts Counts to use for clustering. Can be corrected counts
#' or raw counts
#' @param plate_matrix Meta information as matrix 
#'
#' @return Plate matrix with the added cluster information
#' @export 
#'
#' @examples
seurat_clustering = function(counts, plate_matrix) {
  # Create Seurat data object
  data.seurat = CreateSeuratObject(counts)
  
  # Normalise the data
  data.seurat = NormalizeData(data.seurat)
  
  # Feature selection
  data.seurat = FindVariableFeatures(data.seurat)
  
  # Scale data
  data.seurat = ScaleData(data.seurat)
  
  # Run the PCA as preprocessing for the UMAP
  data.seurat = RunPCA(data.seurat)
  
  # Create UMAP based on the first 30 Pricnipal components of the analysis
  data.seurat = RunUMAP(data.seurat,features=VariableFeatures(data.seurat))
  
  # Construct neighbourhood graph and find nearest neighbours
  data.seurat = FindNeighbors(data.seurat)
  
  # Find clusters within the neighbourhood graph
  data.seurat = FindClusters(data.seurat)
  
  # Put the cluster information into the metadata matrix
  plate_matrix$Seurat_clusters = Idents(data.seurat)
  
  # Uncomment this for finer grained resolution
  #Idents(object = data.seurat) <- "integrated_snn_res.0.8"
  
  # Plot the clusters into scatterplot
  seurat_plot = DimPlot(data.seurat,
                        reduction = "umap",
                        label = TRUE,
                        label.size = 6)
  
  # Save plots
  ggsave(
    "test_seurat.png",
    plot = seurat_plot,
    dpi = 300,
    bg = 'white',
    width = 22, 
    height = 15,
    unit="in"
  )
  
  return(plate_matrix)
}


#' sr SHC clustering based on paper: "Significance analysis
#'  for clustering with single-cell RNA-sequencing data"
#' @param counts Counts to use for clustering. Can be corrected counts
#' or raw counts
#' @param plate_matrix Meta information as matrix 
#'
#' @return Plate matrix with the added cluster information
#'
#'
#' @examples
sr_SHC_clustering = function(counts, plate_matrix) {
  
  clusters = scSHC(
    counts,
    batch = plate_matrix$Plate, # maybe feed in plate information here?
    alpha = 0.5, # For discovery more lenient
    num_features = 500, # Controls how many genes to look at
    num_PCs = 5, # Number of principal components to incorporate for the UMAP
    parallel = TRUE, 
    cores = 20
  )
  
  # Get the cluster information and the cluster tree
  cluster_tree = clusters[[2]]
  clusters = clusters[[1]]
  clusters = clusters[ order(names(clusters))]
  
  plate_matrix = plate_matrix[order(rownames(plate_matrix)), ]
  
  # Feed cluster information back into the meta data table
  plate_matrix$sc_SCH_Clusters = as.factor(clusters)
  return(plate_matrix)
}

# Process data for functional annotation ######################################

ProcessRes = function(geneList, orgdb) {
    geneList = geneList[!is.na(names(geneList))]
    geneList = sort(geneList, decreasing = TRUE)
    if (basename(orgdb) != "org.Bcinerea.eg.db") {
      geneList = geneList[grepl("XP_*", names(geneList))]
    }

    geneList = geneList[names(geneList) %in% keys(get(orgdb), keytype = "GID")]
    return(geneList)
}

go_enrichment = function(input_tuple) {
    genelist = input_tuple[[1]]
    orgdb = input_tuple[[2]]
    ont = input_tuple[[3]] 
    treatment =  input_tuple[[4]]
    plottitle =  input_tuple[[5]]
    keytype = input_tuple[[6]]
    
    g = tryCatch( {
    go = enrichGO(
        gene          = names(genelist),
        universe      = keys(orgdb, keytype = keytype),
        OrgDb         = orgdb,
        keyType       = keytype,
        ont           = ont,
        pAdjustMethod = "BH",
        pvalueCutoff  = 0.1,
        qvalueCutoff  = 0.3,
        readable      = TRUE)
    go = as.data.frame(go)
    
    g = tryCatch( {
    if (dim(go)[1] <= 2){
        return(list())
    }
     }, error=function(e) {
        return(list()) 
    })
    
    go$adj_pval = go$p.adjust
    go$Term = go$Description
    go$genes = go$geneID
    go$category = ont
    
    }, error=function(e) {
        return(list()) 
    })
    
    g = tryCatch( {
    if (dim(go)[1] <= 2){
        return(list())
    }
     }, error=function(e) {
        return(list()) 
    })
    
    g = tryCatch( {
        g = goplot(go, warning = FALSE, message = FALSE, fig.keep = 'none')

        g = g + ggtitle(plottitle) + theme(plot.title = element_text(hjust = 0.5))

        ggsave(
            paste0(treatment, "_GO_", ont, "_network.png"),
            plot = g,
            dpi = 300,
            bg = 'white',
            width = 15, 
            height = 15,
            unit="in"
        )
     }, error=function(e) {
        g = NULL     
    })
    
    g = tryCatch( {
        g = barplot(go, showCategory=20)
        g = g + ggtitle(plottitle) + theme(plot.title = element_text(hjust = 0.5))
        ggsave(
            paste0(treatment, "_GO_", ont, "_barplot.png"),
            plot = g,
            dpi = 300,
            bg = 'white',
            width = 15, 
            height = 15,
            unit="in"
        )
     }, error=function(e) {
         g = NULL  
    })
    
    g = tryCatch( {
        g = barplot(go, showCategory=20)
        g = g + ggtitle(plottitle) + theme(plot.title = element_text(hjust = 0.5))
        ggsave(
            paste0(treatment, "_GO_", ont, "_barplot.png"),
            plot = g,
            dpi = 300,
            bg = 'white',
            width = 15, 
            height = 15,
            unit="in"
        )
    }, error=function(e) {
        g = NULL     
    })
    
    g = tryCatch( {
        g = dotplot(go, showCategory=20)
        g = g + ggtitle(plottitle) + theme(plot.title = element_text(hjust = 0.5))
        ggsave(
            paste0(treatment, "_GO_", ont, "_dotplot.png"),
            plot = g,
            dpi = 300,
            bg = 'white',
            width = 15, 
            height = 15,
            unit="in"
        )
    }, error=function(e) {
        g = NULL     
    })
    
    g = tryCatch( {
        g = cnetplot(
            go,
            foldChange=genelist,
            categorySize="pvalue",
            circular = TRUE,
            colorEdge = TRUE
        )
        g = g + ggtitle(plottitle) + theme(plot.title = element_text(hjust = 0.5))
        ggsave(
            paste0(treatment, "_GO_", ont, "_dotplot.png"),
            plot = g,
            dpi = 300,
            bg = 'white',
            width = 15, 
            height = 15,
            unit="in"
        )
     }, error=function(e) {
        g = NULL     
    })
    
    g = tryCatch( {
        g = heatplot(
            go,
            foldChange=genelist,
            showCategory=5
        )
            
        g = g + ggtitle(plottitle) + theme(plot.title = element_text(hjust = 0.5))
        ggsave(
            paste0(treatment, "_GO_", ont, "_heatplot.png"),
            plot = g,
            dpi = 300,
            bg = 'white',
            unit="in"
        )
    }, error=function(e) { 
        g = NULL     
    })
    
    g = tryCatch( {
        gox = pairwise_termsim(go)
        g = treeplot(
            gox,
            hclust_method = "average",
        )
            
        g = g + ggtitle(plottitle) + theme(plot.title = element_text(hjust = 0.5))
        ggsave(
            paste0(treatment, "_GO_", ont, "_treeplot.png"),
            plot = g,
            dpi = 300,
            bg = 'white',
            width = 15, 
            height = 15,
            unit="in"
        )
    }, error=function(e) { 
        g = NULL     
    })
    
    g = tryCatch( {
        g = upsetplot(
            go
        )
        g = g + ggtitle(plottitle) + theme(plot.title = element_text(hjust = 0.5))
        ggsave(
            paste0(treatment, "_GO_", ont, "_upsetplot.png"),
            plot = g,
            dpi = 300,
            bg = 'white',
            width = 15, 
            height = 15,
            unit="in"
        )
    }, error=function(e) { 
        g = NULL     
    })
    
    #gox <- setReadable(go, 'org.Hs.eg.db', keytype)
    
   
    return(go)
}

process_go = function(go, ont) {
    go = as.data.frame(go)
    go$adj_pval = go$p.adjust
    go$Term = go$Description
    go$genes = go$geneID
    go$category = ont
    
    return(go)
}

GOplot = function(go_df, res, prefix) {
    
    g = tryCatch( {
      circ = circle_dat(go_df, res)

      g = GOBar(circ[circ$adj_pval < 0.1,], display = 'multiple', title = 'Z-score coloured barplot', zsc.col = c('yellow', 'black', 'cyan'))

      ggsave(
          paste0(prefix, "_GO_bar.png"),
          plot = g,
          dpi = 300,
          bg = 'white',
          width = 15, 
          height = 15,
          unit="in"
      )
      reduced_circ = reduce_overlap(circ, overlap = 0.75)
    }, error=function(e) {
      return()  
    })

    g = tryCatch( {

    g_bub = GOBubble(
        reduced_circ,
        title = 'Bubble plot with background colour',
        display = 'single',
        #bg.col = T,
        labels = 1)

    ggsave(
        paste0(prefix, "_GO_bubble.png"),
        plot = g_bub,
        dpi = 300,
        bg = 'white',
        width = 30, 
        height = 15,
        unit="in"
    )
    }, error=function(e) {
       g = "none"   
    })
    #circ[is.na(circ)] <- 0
   
    g = tryCatch( {
       circ = circ[!is.na(circ$zscore),]
        g = GOCircle(circ)
        ggsave(
            paste0(prefix, "_GO_circle.png"),
            plot = g,
            dpi = 300,
            bg = 'white',
            width = 30, 
            height = 15,
            unit="in"
        )
    }, error=function(e) {
       g = "none"   
    }
    )
    
    g = tryCatch( {
        g = GOCluster(circ, process, clust.by = 'logFC', term.width = 2)
        ggsave(
            paste0(prefix, "_GO_cluster.png"),
            plot = g,
            dpi = 300,
            bg = 'white',
            width = 20, 
            height = 12,
            unit="in"
        )
    }, error=function(e) {
       g = "none"   
    }
    )

    #if (dim(chord)[1] > 10) {
    #    chord = chord[1:10,]
    #}
    
    genes = as.data.frame(cbind(circ$genes, as.numeric(circ$logFC)))
    colnames(genes) = c("ID", "logFC")
    genes[,"logFC"] = as.numeric(genes[,"logFC"])
    circ = circ[order(circ[,"adj_pval"]),]
    process =  circ[1:8,]$term

    genes = genes[genes$ID != "CDS", ]
    if (dim(genes)[1] <= 2){
        return()
    }
    g = tryCatch( {
        genes = aggregate(genes$logFC, list(genes$ID), mean)
    }, error=function(e) {
       g = "none"   
    })
    colnames(genes) = c("ID", "logFC")
    genes = genes[order(-abs(as.numeric(genes$logFC))),]
   
    chord = chord_dat(data = circ, genes = genes, process = process)
    translate_log2FC = as.numeric(genes$logFC)
    names(translate_log2FC) = genes$ID
    chord[,"logFC"] = translate_log2FC[rownames(chord)]
    if (dim(genes)[1] > 15) {
        genes = genes[1:15,]
    }
    
    g = tryCatch( {
            g = GOChord(
            chord, 
            #space = 0.02,
            gene.order = 'logFC', 
            #gene.space = 0.25,
            #gene.size = 5
        )
    ggsave(
            paste0(prefix, "_GO_chord.png"),
            plot = g,
            dpi = 300,
            bg = 'white',
            unit="in"
    )}, error=function(e) {
       g = "none"   
    })
    
    g = tryCatch( {
        g = GOHeat(chord, nlfc = 1, )
        
        ggsave(
            paste0(prefix, "_Go_heat.png"),
            plot = g,
            dpi = 300,
            bg = 'white',
            unit="in"
        )      
    }, error=function(e) {
       g = "none"   
    }
    )
}

KEGGplot = function(gene_ids, pathway, treatment, species) {
    g = tryCatch( {
    pathview(
        gene.data  = gene_ids,
        pathway.id = pathway,
        species    = species,
        out.suffix = treatment,
    )
    }, error=function(e) {
        g = "none"   
    })
    
}


EnrichKegg = function(gene_ids, kegg_df, treatment) {

    enr_res = enricher(
      names(gene_ids),
      pvalueCutoff = 0.05,
      pAdjustMethod = "BH",
      minGSSize = 10,
      maxGSSize = 500,
      qvalueCutoff = 0.3,
      TERM2GENE=kegg_df,
    )
    kegg2gene = kegg_df$KEGG_ko
    names(kegg2gene) = kegg_df$X.query

    #if (grepl("^bcin", tolower(names(gene_ids[1])))) {
    #  organism_kegg = "bfu"
    #  names(gene_ids) <- gsub("Bcin", "BCIN_", names(gene_ids))
    #  names(gene_ids) <- gsub("p", "g", names(gene_ids))
    #  keytype = "kegg"
    #} else {
    organism_kegg = "ko"
    names(gene_ids) = kegg2gene[names(gene_ids)]
    gene_ids = gene_ids[names(gene_ids)!="-"]
    keytype = "kegg"
    #}

    kegg_enrich = enrichKEGG(
      names(gene_ids),
      organism = organism_kegg,
      keyType = keytype,
      pvalueCutoff = 0.05,
      pAdjustMethod = "BH",
      minGSSize = 10,
      maxGSSize = 500,
      qvalueCutoff = 0.1,
      use_internal_data = FALSE
    )
    
    g = tryCatch( {
        keggx =  pairwise_termsim(kegg_enrich)
        g = emapplot(keggx, pie="count", cex_category=1.5, layout="kk")

        ggsave(
            paste0(treatment, "_KEGG_clusterplot.png"),
            plot = g,
            dpi = 300,
            bg = 'white',
            width = 15, 
            height = 15,
            unit="in"
        )
     }, error=function(e) { 
        g = NULL     
    })
    
    g = tryCatch( {
        g = upsetplot(
            kegg_enrich
        )
        ggsave(
            paste0(treatment, "_KEGG_upsetplot.png"),
            plot = g,
            dpi = 300,
            bg = 'white',
            width = 15, 
            height = 15,
            unit="in"
        )
     }, error=function(e) { 
        g = NULL     
    })
    
    for (pathway in kegg_enrich[,"ID"]) {
      # Extract gene IDs from the geneID column
      #geneID_str <- kegg_enrich$geneID
      #geneID_vector <- unlist(strsplit(geneID_str, "/"))
      #gene_ids = as.numeric(gene_ids)
      # Filter gene_ids to include only those in geneID_vector
      #filtered_gene_ids <- gene_ids[names(gene_ids) %in% geneID_vector]
      
      KEGGplot(
          gene_ids,
          pathway,
          treatment,
          organism_kegg
      )
    }
    return(kegg_enrich)
}

EnrichKegg_human = function(gene_ids, treatment) {
    names(gene_ids) = mapIds(org.Hs.eg.db, names(gene_ids), 'ENTREZID', 'ENSEMBL')
    gene_ids = gene_ids[!is.na(names(gene_ids))]
    
    kegg_enrich = enrichKEGG(
      names(gene_ids),
      organism = 'hsa',
      keyType = "kegg",
      pvalueCutoff = 0.05,
      pAdjustMethod = "BH",
      minGSSize = 10,
      maxGSSize = 500,
      qvalueCutoff = 0.1,
    )
    g = tryCatch( {
        keggx =  pairwise_termsim(kegg_enrich)
        g = emapplot(keggx, pie="count", cex_category=1.5, layout="kk")

        ggsave(
            paste0(treatment, "_KEGG_clusterplot.png"),
            plot = g,
            dpi = 300,
            bg = 'white',
            width = 15, 
            height = 15,
            unit="in"
        )
     }, error=function(e) { 
        g = NULL     
    })
    
    g = tryCatch( {
        g = upsetplot(
            kegg_enrich
        )
        ggsave(
            paste0(treatment, "_KEGG_upsetplot.png"),
            plot = g,
            dpi = 300,
            bg = 'white',
            width = 15, 
            height = 15,
            unit="in"
        )
     }, error=function(e) { 
        g = NULL     
    })
    
    
    for (pathway in kegg_enrich[,"ID"]) {
      KEGGplot(
          filtered_gene_ids,
          pathway,
          treatment,
          "hsa"
      )
    }
    return(kegg_enrich)
}


GetOrgdb = function(orgdb_name) {
    #tmpdir = "./datapond/RefGenomes/MakeAnnotations/orgdb/" 
    install.packages(orgdb_name, type = "source", repos=NULL)
    orgdb_name = basename(orgdb_name)

    library(orgdb_name, character.only=TRUE)
}


GetGene2ID = function(gtf) {
    gtf = data.frame(read.table(gtf, header = FALSE, sep = '\t'))
    gtf = gtf[gtf$V3 == "CDS",]
    gtf = data.frame(do.call('rbind', strsplit(as.character(gtf$V9),';',fixed=TRUE)))
    gtf$X1 = gsub(".* ","",gtf$X1)
    gtf$X16 = gsub(".* ","",gtf$X16)

    gtf$X16 = gsub("[.].*","",gtf$X16)

    gene2geneID = gtf$X16
    names(gene2geneID) = gtf$X1
    return(gene2geneID)
}

PrepEggnog = function(eggnog_map) {
    eggnog_data = read.csv(
        eggnog_map,
        skip = 4,
        header = TRUE, 
        sep = "\t")

    eggnog_data$X.query = gsub("[.].*","", eggnog_data$X.query)

    eggnog_data$seed_ortholog = gsub(".*[.]","", eggnog_data$seed_ortholog)
    gene2orthologue = eggnog_data$seed_ortholog
    names(gene2orthologue) = eggnog_data$X.query

    eggnog_data$organism = gsub(".*[|]","",eggnog_data$eggNOG_OGs)
    gene2ortho_organism = eggnog_data$organism
    names(gene2ortho_organism) = eggnog_data$X.query

    #get columns 1 (query) and 9 (KO terms)
    kegg <- eggnog_data[c(1,9)]
    # clean up by removing the "ko:" in front of every KO term
    kegg$KEGG_ko <- gsub( "ko:", "", as.character(eggnog_data$KEGG_ko))
    # expand, since some genes/proteins will have multiple assigned KO terms
    kegg <- data.table(kegg)
    kegg <- kegg[, list(KEGG_ko = unlist(strsplit(KEGG_ko , ","))), by = X.query]

    # select the needed columns
    kegg_final <- kegg[,c(2,1)]
    return(kegg_final)
}

functional_analysis = function(dds, orgdb_name, gene2geneID, treatment, kegg) {
  res = results(
    dds,
    alpha = 0.05,
    contrast = c(
      "Treatments",
      treatment,
      "DMSO"
    ),
  )
  orgdb_name = basename(orgdb_name)  

  res = res[!is.na(res[,"padj"]),]
  res = res[res[,"padj"] <= 0.05,]
  res = res[abs(res[,"log2FoldChange"]) > 1,]
  if (dim(res)[1] <= 10) {
      print("Less than 10 genes under significance and logfold threshold")
      return()
  }

  geneList = res[,"log2FoldChange"]
  names(geneList) = gene2geneID[rownames(res)]
  geneList = ProcessRes(geneList, orgdb_name)

  function_arguments = list(
    list(geneList, get(orgdb_name), "CC", treatment, "Go enrichment cellular compartment", "GID"),
    list(geneList, get(orgdb_name), "MF", treatment, "Go enrichment molecular function", "GID"),
    list(geneList, get(orgdb_name), "BP", treatment,  "Go enrichment biological process", "GID")
  )

  go_enriched = lapply(function_arguments, go_enrichment)

  go_df = do.call("rbind", go_enriched)
  if (dim(go_df)[1] < 3){
        return()
  }
     
  go_df$genes <- gsub('/', ', ', go_df$genes)
  g = tryCatch( {
    #go_df = go_df[order(go_df$p.adjust),]
    res$ID = gene2geneID[rownames(res)]

    res$logFC = res$log2FoldChange
    res = res[!is.na(res$ID),]

    GOplot(go_df, res, treatment)
    EnrichKegg(geneList, kegg, treatment)
  }, error=function(e) {
        print(go_df)
  })
}

GetHub = function(species_name) {
    hub = AnnotationHub()
    q = query(hub, species_name)
    id = q$ah_id[length(q)]
    annotation = hub[[id]]
    return(annotation)
}


functional_analysis_human = function(dds) {
  res = results(
    dds,
    alpha = 0.05,
    contrast = c(
      "Treatments",
      treatment,
      "DMSO"
    ),
  )
    
  res = res[!is.na(res[,"padj"]),]
  res = res[res[,"padj"] <= 0.05,]
  res = res[abs(res[,"log2FoldChange"]) > 1,]
  if (dim(res)[1] <= 10) {
      print("Less than 10 genes under significance and logfold threshold")
      return()
  }

  geneList = res[,"log2FoldChange"]
  names(geneList) = rownames(res)
  library('org.Hs.eg.db')
    
  function_arguments = list(
    list(geneList, org.Hs.eg.db, "CC", treatment, "Go enrichment cellular compartment", "ENSEMBL"),
    list(geneList,  org.Hs.eg.db, "MF", treatment, "Go enrichment molecular function","ENSEMBL"),
    list(geneList,  org.Hs.eg.db, "BP", treatment, "Go enrichment biological process","ENSEMBL")
      )

  go_enriched = lapply(function_arguments, go_enrichment)

  go_df = do.call("rbind", go_enriched)
  if (dim(go_df)[1] <= 3){
        return()
  }
     
  go_df$genes <- gsub('/', ', ', go_df$genes)
  #g = tryCatch( {
  go_df = go_df[order(go_df$p.adjust),]

  res$logFC = res$log2FoldChange
  res = res[!is.na(res$ID),]

  GOplot(go_df, res, treatment)
  EnrichKegg_human(geneList, treatment)
  #}, error=function(e) {
  #     print("Did not work")
  #     print(go_df)
  #})
}